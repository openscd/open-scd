{"version":3,"file":"ortho-connector.js","sourceRoot":"","sources":["../../../src/editors/singlelinediagram/ortho-connector.ts"],"names":[],"mappings":"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","sourcesContent":["interface Point {\n  x: number;\n  y: number;\n}\n\ninterface Adjacent {\n  point: Point;\n  edgeWeight: number;\n}\n\ninterface GraphNode {\n  point: Point;\n  adjacent: Adjacent[];\n  dist: number;\n  path: Point[];\n}\n\nfunction distance(a: Point, b: Point): number {\n  return Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n}\n\nfunction isChangedDirection(a: GraphNode, b: GraphNode): boolean {\n  if (a.path.length === 0) return false;\n\n  const commingX2 = a.point.x;\n  const commingX1 = a.path[a.path.length - 1].x;\n  const commingHorizontal = commingX2 - commingX1 ? false : true;\n\n  const goingHorizontal = a.point.x - b.point.x ? false : true;\n\n  return commingHorizontal !== goingHorizontal;\n}\n\nfunction filterUnchangedDirection(path: Point[]): Point[] {\n  return path.filter((p, i, v) => {\n    if (i === 0 || i === v.length - 1) return true;\n\n    const commingDirection =\n      v[i].x - v[i - 1].x !== 0 ? 'horizontal' : 'vertical';\n    const goingDirection =\n      v[i + 1].x - v[i].x !== 0 ? 'horizontal' : 'vertical';\n\n    return commingDirection === goingDirection ? false : true;\n  });\n}\n\nfunction calculateMinimumDistance(\n  adjacent: GraphNode,\n  edgeWeigh: number,\n  parentNode: GraphNode\n) {\n  const sourceDistance = parentNode.dist;\n\n  const changingDirection = isChangedDirection(parentNode, adjacent);\n  const extraWeigh = changingDirection ? Math.pow(edgeWeigh + 1, 2) : 0;\n\n  if (sourceDistance + edgeWeigh + extraWeigh < adjacent.dist) {\n    adjacent.dist = sourceDistance + edgeWeigh + extraWeigh;\n    const shortestPath: Point[] = [...parentNode.path];\n    shortestPath.push(parentNode.point);\n    adjacent.path = shortestPath;\n  }\n}\n\nfunction getLowestDistanceGraphNode(\n  unsettledNodes: Set<GraphNode>\n): GraphNode | null {\n  let lowestDistance = Number.MAX_SAFE_INTEGER;\n  let lowestDistanceNode: GraphNode | null = null;\n\n  for (const node of unsettledNodes)\n    if (node.dist < lowestDistance) {\n      lowestDistance = node.dist;\n      lowestDistanceNode = node;\n    }\n\n  return lowestDistanceNode;\n}\n\nfunction dijkstra(graph: GraphNode[], start: GraphNode): Point[] {\n  start.dist = 0;\n\n  const settledNodes: Set<GraphNode> = new Set();\n  const unsettledNodes: Set<GraphNode> = new Set();\n\n  unsettledNodes.add(start);\n\n  while (unsettledNodes.size != 0) {\n    const currentNode = getLowestDistanceGraphNode(unsettledNodes)!;\n    unsettledNodes.delete(currentNode);\n\n    for (const adjacent of currentNode.adjacent) {\n      const adjacentNode = graph.find(\n        node =>\n          node.point.x === adjacent.point.x && node.point.y === adjacent.point.y\n      );\n      const edgeWeight = adjacent.edgeWeight;\n      if (adjacentNode && !settledNodes.has(adjacentNode)) {\n        calculateMinimumDistance(adjacentNode, edgeWeight, currentNode);\n        unsettledNodes.add(adjacentNode);\n      }\n    }\n    settledNodes.add(currentNode);\n  }\n\n  return [];\n}\n\nfunction findClosestGraphNode(\n  graph: GraphNode[],\n  point: Point\n): GraphNode | undefined {\n  const distFromGraphNodes = graph.map(\n    node => Math.abs(point.x - node.point.x) + Math.abs(point.y - node.point.y)\n  );\n\n  const minDistance = Math.min(...distFromGraphNodes);\n  const index = distFromGraphNodes.indexOf(minDistance);\n\n  return graph[index];\n}\n\nfunction addStartNode(graph: GraphNode[], start: Point): GraphNode | undefined {\n  const closestToStart = findClosestGraphNode(graph, start)?.point;\n  if (!closestToStart) return undefined;\n\n  const startNode = {\n    point: start,\n    adjacent: [\n      { point: closestToStart, edgeWeight: distance(start, closestToStart) },\n    ],\n    dist: Number.MAX_SAFE_INTEGER,\n    path: [],\n  };\n  graph.push(startNode);\n\n  return startNode;\n}\n\nfunction getPath(graph: GraphNode[], start: Point, end: Point): Point[] {\n  const startNode = addStartNode(graph, start);\n  const closestToEnd = findClosestGraphNode(graph, end);\n\n  if (!startNode || !closestToEnd) return [];\n\n  dijkstra(graph, startNode);\n  const shortestPath = closestToEnd.path.concat(closestToEnd.point);\n\n  return filterUnchangedDirection(shortestPath).concat([end]);\n}\n\nfunction findGraphNode(\n  graph: GraphNode[],\n  x: number,\n  y: number\n): GraphNode | undefined {\n  return graph.find(node => node.point.x === x && node.point.y === y);\n}\n\nfunction findAdjacent(\n  graph: GraphNode[],\n  currentNode: GraphNode,\n  gridSize: number,\n  type: string\n): Adjacent | null {\n  let dX1: number;\n  let dY1: number;\n\n  if (type === 'prevX') {\n    dX1 = currentNode.point.x - gridSize;\n    dY1 = currentNode.point.y;\n  } else if (type === 'prevY') {\n    dX1 = currentNode.point.x;\n    dY1 = currentNode.point.y - gridSize;\n  } else if (type === 'nextX') {\n    dX1 = currentNode.point.x + gridSize;\n    dY1 = currentNode.point.y;\n  } else {\n    dX1 = currentNode.point.x;\n    dY1 = currentNode.point.y + gridSize;\n  }\n\n  if (findGraphNode(graph, dX1!, dY1!)) {\n    return {\n      point: findGraphNode(graph, dX1!, dY1!)!.point,\n      edgeWeight: gridSize,\n    };\n  }\n\n  return null;\n}\n\nfunction createGraph(allocation: number[][], gridSize: number): GraphNode[] {\n  const graph: GraphNode[] = [];\n  for (let row = 0; row < allocation.length; row++)\n    for (let col = 0; col < allocation[row].length; col++)\n      if (allocation[row][col] === 0)\n        graph.push({\n          point: {\n            x: col * gridSize + gridSize / 2,\n            y: row * gridSize + gridSize / 2,\n          },\n          adjacent: [],\n          dist: Number.MAX_SAFE_INTEGER,\n          path: [],\n        });\n\n  for (const node of graph) {\n    const adjacents = <Adjacent[]>(\n      ['prevX', 'prevY', 'nextX', 'nextY']\n        .map(type => findAdjacent(graph, node, gridSize, type))\n        .filter(adjacent => adjacent)\n    );\n    node.adjacent = adjacents;\n  }\n\n  return graph;\n}\n\nfunction emptyAllocation(\n  start: Point,\n  end: Point,\n  gridSize: number\n): (0 | 1)[][] {\n  const maxX = start.x > end.x ? start.x : end.x;\n  const maxY = start.y > end.y ? start.y : end.y;\n\n  const emptyGrid: (0 | 1)[][] = [];\n  for (let i = 0; i <= Math.ceil(maxY / gridSize) + 1; i++) {\n    emptyGrid[i] = [];\n    for (let j = 0; j <= Math.ceil(maxX / gridSize) + 1; j++) {\n      emptyGrid[i][j] = 0;\n    }\n  }\n\n  emptyGrid[Math.floor(start.y / gridSize)][Math.floor(start.x / gridSize)] = 1;\n  emptyGrid[Math.floor(end.y / gridSize)][Math.floor(end.x / gridSize)] = 1;\n\n  return emptyGrid;\n}\n\n//FIXME: This is a dirty trick to improve performance of the algorithm\nfunction trimStartEnd(start: Point, end: Point, gridSize: number): Point[] {\n  //FIXME: Dirty hack to speed up the algorithm\n  const minCoordX = Math.min(\n    Math.floor(start.x / gridSize),\n    Math.floor(end.x / gridSize)\n  );\n  const minCoordY = Math.min(\n    Math.floor(start.y / gridSize),\n    Math.floor(end.y / gridSize)\n  );\n\n  const dCoordX = minCoordX > 1 ? minCoordX - 1 : 0;\n  const dCoordY = minCoordY > 1 ? minCoordY - 1 : 0;\n\n  const deltaX = dCoordX * gridSize;\n  const deltaY = dCoordY * gridSize;\n\n  return [\n    { x: start.x - deltaX, y: start.y - deltaY },\n    { x: end.x - deltaX, y: end.y - deltaY },\n  ];\n}\n\nfunction fullPath(\n  path: Point[],\n  start: Point,\n  end: Point,\n  trimmedStart: Point,\n  trimmedEnd: Point\n): Point[] {\n  if (start === trimmedStart && end === trimmedEnd) return path;\n\n  const deltaX = start.x - trimmedStart.x;\n  const deltaY = start.y - trimmedStart.y;\n\n  return path.map(point => {\n    return { x: point.x + deltaX, y: point.y + deltaY };\n  });\n}\n\n/** Finds the shortest orthogonal path between start and end based on grid and dijkstra path finding algorithm\n * @param start - the position in px of the start point\n * @param end - the position in px of the end point\n * @param gridSize - grid size of the grid to rout in the orthogonal path\n * @param gridAllocation - optional [][] matrix to define allocated grid cells\n * @returns - Array of positions in px building the orthogonal path\n */\nexport function getOrthogonalPath(\n  start: Point,\n  end: Point,\n  gridSize: number,\n  gridAllocation?: (0 | 1)[][]\n): Point[] {\n  if (start.x === end.x && start.y === end.y) return [];\n\n  let trimmedStart = start;\n  let trimmedEnd = end;\n\n  if (!gridAllocation) {\n    [trimmedStart, trimmedEnd] = trimStartEnd(start, end, gridSize);\n    gridAllocation = emptyAllocation(trimmedStart, trimmedEnd, gridSize);\n  }\n\n  const graph: GraphNode[] = createGraph(gridAllocation!, gridSize);\n\n  const shortesPath = getPath(graph, trimmedStart, trimmedEnd);\n\n  return fullPath(shortesPath, start, end, trimmedStart, trimmedEnd);\n}\n"]}