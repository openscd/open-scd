{"version":3,"file":"foundation.js","sourceRoot":"","sources":["../../../../src/editors/protocol104/foundation/foundation.ts"],"names":[],"mappings":"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","sourcesContent":["import { html, TemplateResult } from 'lit-element';\nimport { ifDefined } from 'lit-html/directives/if-defined.js';\n\nimport { get } from 'lit-translate';\nimport {\n  getInstanceAttribute,\n  getNameAttribute,\n} from '@openscd/open-scd/src/foundation.js';\nimport { typeMaxLength } from '../../../wizards/foundation/p-types.js';\nimport { typeDescriptiveNameKeys, typePattern } from './p-types.js';\n\n/**\n * Retrieve the full path as wanted for the IED Container in the 104 Plugin, meaning we go higher in the\n * hierarchy until the parent found is the IED, this element is excluded, because the containers are group per\n * IED.\n * From all parent between the DAI and IED the name or likely attributes are used to define a unique name.\n *\n * @param element - The DAI Element for which the full path needs to be defined.\n * @param topLevelTagName - Name of the Tag to stop at when travelling through the parents (excluding).\n * @returns The full path shown to the user for a DAI Element.\n */\nexport function getFullPath(element: Element, topLevelTagName: string): string {\n  let currentElement: Element | null = element;\n  const paths: string[] = [];\n\n  do {\n    let value: string | undefined;\n    switch (currentElement.tagName) {\n      case 'LN':\n      case 'LN0': {\n        const prefix = currentElement.getAttribute('prefix');\n        const inst = getInstanceAttribute(currentElement);\n        value = `${prefix ? prefix + '-' : ''}${currentElement.getAttribute(\n          'lnClass'\n        )}${inst ? '-' + inst : ''}`;\n        break;\n      }\n      case 'LDevice': {\n        value =\n          getNameAttribute(currentElement) ??\n          getInstanceAttribute(currentElement);\n        break;\n      }\n      default: {\n        // Just add the name to the list\n        value = getNameAttribute(currentElement);\n      }\n    }\n    if (value) {\n      paths.unshift(value);\n    }\n    currentElement = currentElement.parentElement;\n  } while (currentElement && currentElement.tagName != topLevelTagName);\n\n  return paths.join(' / ');\n}\n\n/**\n * Retrieve the CDC Value that belongs to a DAI Element, meaning, using the DOI/LN Elements to\n * search for a DO Element, which is again used to find the DO/DOType Element. The DOType Element\n * finally holds the attribute 'cdc'.\n *\n * @param doiElement - The DOI Element to start the search for the CDC Value.\n * @returns The CDC Value from the DOType Element.\n */\nexport function getCdcValueFromDOIElement(doiElement: Element): string | null {\n  const lnElement = doiElement.closest('LN0, LN');\n  if (lnElement) {\n    const lnType = lnElement.getAttribute('lnType');\n    const doName = doiElement.getAttribute('name');\n\n    const doElement = doiElement.ownerDocument.querySelector(\n      `:root > DataTypeTemplates > LNodeType[id=\"${lnType}\"] > DO[name=\"${doName}\"]`\n    );\n    if (doElement) {\n      return getCdcValueFromDOElement(doElement);\n    }\n  }\n  return null;\n}\n\nexport function getCdcValueFromDOElement(doElement: Element): string | null {\n  const doType = getTypeAttribute(doElement);\n  const doTypeElement = doElement.ownerDocument.querySelector(\n    `:root > DataTypeTemplates > DOType[id=\"${doType}\"]`\n  );\n  return doTypeElement ? doTypeElement.getAttribute('cdc') : null;\n}\n\n/**\n * All available Address attributes that can be displayed.\n */\nconst addressAttributes = [\n  'casdu',\n  'ioa',\n  'ti',\n  'expectedValue',\n  'unitMultiplier',\n  'scaleMultiplier',\n  'scaleOffset',\n  'inverted',\n  'check',\n];\n\n/**\n * Create a string to display all information about a 104 Address element.\n * A list of attributes is used to determine what can be displayed if available.\n *\n * @param daiElement - The DAI Element used if the attribute 'expectedValue' exists to retrieve the Enum Value.\n * @param address    - The Address element from which to retrieve all attribute values.\n * @returns A string to display with all attribute values.\n */\nexport function get104DetailsLine(\n  daiElement: Element,\n  address: Element\n): string {\n  return addressAttributes\n    .filter(attrName => address.hasAttribute(attrName))\n    .map(attrName => {\n      const value = address.getAttribute(attrName)!;\n      if (attrName === 'expectedValue') {\n        const enumValue = getEnumVal(daiElement, value);\n        return `${attrName}: ${value}${enumValue ? ` (${enumValue})` : ``}`;\n      } else {\n        return `${attrName}: ${value}`;\n      }\n    })\n    .join(', ');\n}\n\n/**\n * Extract the 'type' attribute from the given XML element.\n * @param element - The element to extract instance from.\n * @returns the value, or undefined if there is no instance.\n */\nexport function getTypeAttribute(element: Element): string | undefined {\n  const type = element.getAttribute('type');\n  return type ? type : undefined;\n}\n\n/**\n * Search for a DAI Element below the passed DOI Element.\n *\n * @param doElement - The DO Element to search on.\n * @param name      - The name of the DA Element to search for.\n * @returns The found DA Element or null, if not found.\n */\nexport function getDaElement(doElement: Element, name: string): Element | null {\n  const doType = getTypeAttribute(doElement);\n  if (doType) {\n    return doElement.ownerDocument.querySelector(\n      `:root > DataTypeTemplates > DOType[id=\"${doType}\"] > DA[name=\"${name}\"]`\n    );\n  }\n  return null;\n}\n\n/**\n * Search for the Value of a DAI Element below the passed DOI Element.\n *\n * @param doElement - The DO Element to search on.\n * @param name      - The name of the DA Element to search for.\n * @returns The value (Val) of the found DA Element or null, if not found.\n */\nexport function getDaValue(doElement: Element, name: string): string | null {\n  const daElement = getDaElement(doElement, name);\n  if (daElement) {\n    return daElement.querySelector(':scope > Val')?.textContent ?? null;\n  }\n  return null;\n}\n\n/**\n * Search for a DAI Element below the passed DOI Element.\n *\n * @param doiElement - The DOI Element to search on.\n * @param name       - The name of the DAI Element to search for.\n * @returns The found DAI Element or null, if not found.\n */\nexport function getDaiElement(\n  doiElement: Element,\n  name: string\n): Element | null {\n  return doiElement.querySelector(`:scope > DAI[name=\"${name}\"]`);\n}\n\n/**\n * Search for the Value of a DAI Element below the passed DOI Element.\n *\n * @param doiElement - The DOI Element to search on.\n * @param name       - The name of the DAI Element to search for.\n * @returns The value (Val) of the found DAI Element or null, if not found.\n */\nexport function getDaiValue(doiElement: Element, name: string): string | null {\n  const daiElement = getDaiElement(doiElement, name);\n  if (daiElement) {\n    return daiElement.querySelector(':scope > Val')?.textContent ?? null;\n  }\n  return null;\n}\n\nexport function getDoiElement(\n  lnElement: Element,\n  doName: string\n): Element | null {\n  return lnElement.querySelector(`:scope > DOI[name=\"${doName}\"]`);\n}\n\nexport function getDoElement(\n  lnElement: Element,\n  doName: string\n): Element | null {\n  const lnType = lnElement.getAttribute('lnType');\n  if (lnType) {\n    return lnElement.ownerDocument.querySelector(\n      `:root > DataTypeTemplates > LNodeType[id=\"${lnType}\"] > DO[name=\"${doName}\"]`\n    );\n  }\n  return null;\n}\n\nexport function getDoElements(lnElement: Element): Element[] {\n  const lnType = lnElement.getAttribute('lnType');\n  if (lnType) {\n    return Array.from(\n      lnElement.ownerDocument.querySelectorAll(\n        `:root > DataTypeTemplates > LNodeType[id=\"${lnType}\"] > DO`\n      )\n    );\n  }\n  return [];\n}\n\n/**\n * Search for the DAI Element 'ctlModel', this one indicates if control Addresses need to be created.\n *\n * @param lnElement - The LN Element.\n * @param doElement - The DO Element.\n * @returns The value of the CtlModel.\n */\nexport function getCtlModel(\n  lnElement: Element,\n  doElement: Element\n): string | null {\n  const doName = getNameAttribute(doElement);\n  if (doName) {\n    const doiElement = getDoiElement(lnElement, doName);\n    if (doiElement) {\n      return getDaiValue(doiElement, 'ctlModel');\n    } else {\n      return getDaValue(doElement, 'ctlModel');\n    }\n  }\n  return null;\n}\n\n/**\n * Create a Array of Elements from the DOI Element to the passed daiElement.\n * This will contain of course the DOI Element, followed by zero or more SDI Elements\n * and finally the DAI Element with which we started.\n *\n * @param daiElement - The DAI Element to start walking to the LN(0) Element through parents.\n */\nfunction buildInstanceChain(daiElement: Element): Element[] {\n  const instanceElementChain: Element[] = [daiElement];\n  let child = daiElement;\n  if (child.parentElement) {\n    // While the parent element exists and the parent that was processed isn't the LN(0) Element continue.\n    do {\n      child = child.parentElement;\n      instanceElementChain.unshift(child);\n    } while (child.tagName !== 'DOI' && child.parentElement);\n  }\n  return instanceElementChain;\n}\n\n/**\n * Use the initialed elements (DOI/SDI/DAI) to make the same chain containing the template elements like\n * DO/SDO/DA/BDA. This way all needed configuration values can be retrieved from the templates.\n *\n * @param doc           - The document which will be used to search different template elements.\n * @param instanceChain - The chain created from the LN(0) to the DAI in the IED.\n */\nfunction buildTemplateChainFromInstanceElements(\n  doc: Document,\n  instanceChain: Element[]\n): Element[] {\n  const templateChain: Element[] = [];\n  let typeElement: Element | null;\n  instanceChain.forEach(element => {\n    if (element.tagName === 'DOI') {\n      // The LN Element will only be used as starting point to find the LNodeType.\n      const lnElement = element.closest('LN, LN0')!;\n      const typeId = lnElement.getAttribute('lnType') ?? '';\n      typeElement = doc.querySelector(\n        `:root > DataTypeTemplates > LNodeType[id=\"${typeId}\"]`\n      );\n\n      if (typeElement) {\n        // Next search for the DO Element below the LNodeType Element.\n        const name = element.getAttribute('name');\n        const doElement = typeElement.querySelector(\n          `:scope > DO[name=\"${name}\"]`\n        );\n        if (doElement) {\n          templateChain.push(doElement);\n\n          // For the next element search the DOType that is linked to the DO Element.\n          const typeId = getTypeAttribute(doElement) ?? '';\n          typeElement = doc.querySelector(\n            `:root > DataTypeTemplates > DOType[id=\"${typeId}\"]`\n          );\n        } else {\n          typeElement = null;\n        }\n      }\n    } else if (['SDI', 'DAI'].includes(element.tagName)) {\n      if (typeElement) {\n        // Search for the DA Element below the DOType or DAType from the previous Element\n        const name = element.getAttribute('name');\n        const daElement = typeElement?.querySelector(\n          `:scope > DA[name=\"${name}\"], :scope > BDA[name=\"${name}\"]`\n        );\n        if (daElement) {\n          templateChain.push(daElement);\n\n          if (daElement.getAttribute('bType') === 'Struct') {\n            // Only if the bType is a struct we need to search for the DAType for the next element.\n            const typeId = getTypeAttribute(element) ?? '';\n            typeElement = doc.querySelector(\n              `:root > DataTypeTemplates > DAType[id=\"${typeId}\"]`\n            );\n          } else {\n            typeElement = null;\n          }\n        } else {\n          typeElement = null;\n        }\n      }\n    }\n  });\n  return templateChain;\n}\n\n/**\n * Retrieve the DA or BDA Element that's linked to the DAI Element passed.\n *\n * @param daiElement - The DAI Element for which to search the linked DA Element.\n */\nexport function getDaElementByDaiElement(\n  daiElement: Element\n): Element | undefined {\n  // First step is to create the list of instance elements\n  const instanceChain = buildInstanceChain(daiElement);\n  // Next step is to build the Template Chain from the instance elements\n  const templateChain = buildTemplateChainFromInstanceElements(\n    daiElement.ownerDocument,\n    instanceChain\n  );\n  if (templateChain.length > 0) {\n    // The needed DA Element is the last Element from the Chain.\n    const daElement = templateChain.pop();\n    if (['DA', 'BDA'].includes(daElement!.tagName)) {\n      return daElement;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Check if the DA Element is of the bType 'Enum'.\n *\n * @param daElement - The DA Element for which to check.\n */\nfunction isEnumType(daElement: Element | undefined) {\n  return daElement?.getAttribute('bType') === 'Enum' ?? false;\n}\n\n/**\n * Check if the DA Element that's linked to the DAI Element is of the bType 'Enum'.\n *\n * @param daiElement - The DAI Element for which to check.\n */\nexport function isEnumDataAttribute(daiElement: Element): boolean {\n  const daElement = getDaElementByDaiElement(daiElement);\n  return isEnumType(daElement);\n}\n\n/**\n * Retrieve the value of the Enum with passed 'ord' configured with the passed DAI Element.\n *\n * @param daiElement - The DAI Element that is configured as Enum Type.\n * @param ord        - The value of the attribute 'ord' to search the value of.\n */\nexport function getEnumVal(daiElement: Element, ord: string): string | null {\n  const daElement = getDaElementByDaiElement(daiElement);\n  if (isEnumType(daElement)) {\n    const enumType = getTypeAttribute(daElement!);\n    const enumVal = daiElement.ownerDocument.querySelector(\n      `:root > DataTypeTemplates > EnumType[id=\"${enumType}\"] > EnumVal[ord=\"${ord}\"]`\n    );\n    if (enumVal) {\n      return enumVal.textContent;\n    }\n  }\n  return null;\n}\n\n/**\n * Retrieve all the 'ord' value the EnumType has configured with his values.\n *\n * @param daiElement - The DAI Element that is configured as Enum Type.\n */\nexport function getEnumOrds(daiElement: Element): string[] {\n  const ords: string[] = [];\n  const daElement = getDaElementByDaiElement(daiElement);\n  if (isEnumType(daElement)) {\n    const enumType = getTypeAttribute(daElement!);\n    const enumVals = daiElement.ownerDocument.querySelectorAll(\n      `:root > DataTypeTemplates > EnumType[id=\"${enumType}\"] > EnumVal`\n    );\n    Array.from(enumVals)\n      .filter(valElement => valElement.getAttribute('ord'))\n      .map(valElement => ords.push(valElement.getAttribute('ord')!));\n  }\n  return ords;\n}\n\n/**\n * Search for the Element passed from the Cloned LN Structure in the original LN Structure.\n * If that element exists in the original LN Structure it will be returned.\n * If the cloned Element is a new Element 'null' will be returned.\n *\n * @param lnElement     - The original LN Element with the existing Elements.\n * @param clonedElement - The Element to search for in the existing structure using its key.\n * @returns The original element found or null if it didn't exist before.\n */\nexport function findElementInOriginalLNStructure(\n  lnElement: Element,\n  clonedElement: Element\n): Element | null {\n  if (['LN0', 'LN'].includes(clonedElement.tagName)) {\n    return lnElement;\n  }\n\n  // First create a list of elements from the Cloned Element to the Cloned LN Element.\n  const clonedElements: Element[] = [];\n  let currentElement: Element | null | undefined = clonedElement;\n  while (currentElement && !['LN0', 'LN'].includes(currentElement.tagName)) {\n    clonedElements.unshift(currentElement!);\n    currentElement = currentElement?.parentElement;\n  }\n\n  // Walk through the list of Cloned Elements and walk the original LN Structure.\n  let parentElement: Element | null = lnElement;\n  while (parentElement != null && clonedElements.length > 0) {\n    // Get the first Cloned Element from the list and search the element on the original structure\n    const childElement = clonedElements.shift();\n    if (childElement) {\n      // Below the LN there are only DOI/SDI/DAI Elements we need to search for.\n      // The parent can be an LN, DOI or SDI Element.\n      const name = getNameAttribute(childElement);\n      parentElement = parentElement.querySelector(\n        `:scope > DOI[name=\"${name}\"], :scope > SDI[name=\"${name}\"], :scope > DAI[name=\"${name}\"]`\n      );\n    } else {\n      parentElement = null;\n    }\n  }\n  return parentElement;\n}\n\n/**\n * Create a wizard-textfield element for the wizards within the Network part of the 104 plugin.\n * @param pType - The type of P a Text Field has to be created for.\n * @returns - A Text Field created for a specific type for the Create wizard.\n */\nexport function createNetworkTextField(\n  pType: string,\n  maybeValue?: string\n): TemplateResult {\n  return html`<wizard-textfield\n    required\n    label=\"${pType}\"\n    pattern=\"${ifDefined(typePattern[pType])}\"\n    .maybeValue=${maybeValue ?? null}\n    maxLength=\"${ifDefined(typeMaxLength[pType])}\"\n    helper=\"${get(typeDescriptiveNameKeys[pType])}\"\n  ></wizard-textfield>`;\n}\n\n/**\n * Enumeration stating the active view of the 104 plugin.\n */\nexport enum View {\n  VALUES,\n  NETWORK,\n}\n\nexport const VIEW_EVENT_NAME = 'view-change-104-plugin';\n\n// Objects needed to register and fire the change of a view within the Communication 104 Plugin\nexport interface ViewDetail {\n  view: View;\n}\nexport type ViewEvent = CustomEvent<ViewDetail>;\nexport function newViewEvent(view: View): ViewEvent {\n  return new CustomEvent<ViewDetail>(VIEW_EVENT_NAME, {\n    bubbles: true,\n    composed: true,\n    detail: { view },\n  });\n}\n\ndeclare global {\n  interface ElementEventMap {\n    [VIEW_EVENT_NAME]: ViewEvent;\n  }\n}\n"]}