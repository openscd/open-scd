{"version":3,"file":"dai.js","sourceRoot":"","sources":["../../src/foundation/dai.ts"],"names":[],"mappings":"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","sourcesContent":["import { SCL_NAMESPACE } from '../schemas.js';\n\n/**\n * Determine which part of the Template Structure still needs to be initialized.\n * With the first call the parent will normally be the LN(0) Element to start from.\n * It will use the list to pop the first element and look if there is a DOI/SDI/DAI\n * Element available with the same name.\n *\n * @param parentElement     - The element to search from for a DOI/SDI/DAI\n * @param templateStructure - The templates structure with DO/DA/BDA Elements.\n * @returns The last element initialized element or LN(0) if nothing is initialized. This Element can be used to\n *          add the new element to. And the list of Template Elements that still need to be initialized.\n */\nexport function determineUninitializedStructure(\n  parentElement: Element,\n  templateStructure: Element[]\n): [Element, Element[]] {\n  const templateElement = templateStructure.shift();\n  if (templateStructure.length > 0) {\n    // If there are still Template Elements we didn't reach the DAI Element, so continue checking if any DOI/SDI\n    // Element is found with the same name.\n    let instanceElement: Element | null;\n    // DO Elements are initialized as DOI, others as SDI.\n    if (templateElement!.tagName === 'DO') {\n      instanceElement = parentElement.querySelector(\n        `DOI[name=\"${templateElement!.getAttribute('name')}\"]`\n      );\n    } else {\n      instanceElement = parentElement.querySelector(\n        `SDI[name=\"${templateElement!.getAttribute('name')}\"]`\n      );\n    }\n\n    if (instanceElement) {\n      // If instance element found we will search one level lower again.\n      // So the parent will become the instance element and the list is 1 smaller.\n      return determineUninitializedStructure(\n        instanceElement,\n        templateStructure\n      );\n    } else {\n      // No instance element found, so the element and all other elements still need to be\n      // initialized and returned.\n      templateStructure.unshift(templateElement!);\n      return [parentElement, templateStructure];\n    }\n  } else {\n    // The last template element in the list, so this should be the DA Element that only needs\n    // to be initialized.\n    return [parentElement, [templateElement!]];\n  }\n}\n\n/**\n * Create a new instance structure defined by the array of template elements passed.\n *\n * @param uninitializedTemplateStructure - The Array of Template Elements for which new instance elements need to be\n * created.\n * @returns The Element created from the last Template Element in the Array.\n */\nexport function initializeElements(\n  uninitializedTemplateStructure: Element[]\n): Element {\n  const element = uninitializedTemplateStructure.shift();\n  if (uninitializedTemplateStructure.length > 0) {\n    // If there are more template elements left this will become a DOI or SDI Element.\n    let newElement;\n    // Depending on the level create a DOI or SDI Element.\n    if (element!.tagName === 'DO') {\n      newElement = element!.ownerDocument.createElementNS(SCL_NAMESPACE, 'DOI');\n    } else {\n      newElement = element!.ownerDocument.createElementNS(SCL_NAMESPACE, 'SDI');\n    }\n    newElement.setAttribute('name', element?.getAttribute('name') ?? '');\n\n    // Create an element from the next one (last) from the shortened array.\n    const childElement = initializeElements(uninitializedTemplateStructure);\n    newElement.append(childElement);\n\n    return newElement;\n  } else {\n    // Create Val Element\n    const newValElement = element!.ownerDocument.createElementNS(\n      SCL_NAMESPACE,\n      'Val'\n    );\n    const valElement = element!.querySelector('Val');\n    if (valElement) {\n      newValElement.textContent = valElement.textContent;\n    }\n\n    // Create DAI Element\n    const daiElement = element!.ownerDocument.createElementNS(\n      SCL_NAMESPACE,\n      'DAI'\n    );\n    daiElement.setAttribute('name', element?.getAttribute('name') ?? '');\n    daiElement.append(newValElement);\n    return daiElement;\n  }\n}\n\n/**\n * Use the path configuration of a Common Data Class to search for all DO/SDO/DA/BDA Elements to create\n * a structure for which DOI/SDI/DAI Elements should be created later. Null will be returned when an invalid\n * Template Structure is described by the path.\n *\n * @param lnElement - The LN Element to use for searching the starting DO Element.\n * @param path    - The (S)DO/(B)DA Elements to find in the template structure.\n * @returns List of Elements starting with the DO Element followed by one or more SDO or (B)DA Elements describing the structure.\n */\nexport function createTemplateStructure(\n  lnElement: Element,\n  path: string[]\n): Element[] | null {\n  let templateStructure: Element[] | null = [];\n\n  const doc = lnElement.ownerDocument;\n  const lnType = lnElement.getAttribute('lnType') ?? '';\n  let typeElement = doc.querySelector(`LNodeType[id=\"${lnType}\"]`);\n  path.forEach(name => {\n    // There should be a DOType or DAType set for the current element in the list.\n    if (!typeElement) {\n      templateStructure = null;\n      return;\n    }\n    const dataElement = typeElement.querySelector(\n      `:scope > DO[name=\"${name}\"], :scope > SDO[name=\"${name}\"], :scope > DA[name=\"${name}\"], :scope > BDA[name=\"${name}\"]`\n    );\n    // If there is no (S)DO/(B)DA Element found the structure is incorrect, so just stop.\n    if (dataElement === null) {\n      templateStructure = null;\n      return;\n    }\n    templateStructure!.push(dataElement);\n\n    if (dataElement.tagName === 'DO' || dataElement.tagName === 'SDO') {\n      const type = dataElement.getAttribute('type') ?? '';\n      typeElement = doc.querySelector(\n        `DataTypeTemplates > DOType[id=\"${type}\"]`\n      );\n    } else {\n      const bType = dataElement.getAttribute('bType') ?? '';\n      if (bType === 'Struct') {\n        const type = dataElement.getAttribute('type') ?? '';\n        typeElement = doc.querySelector(\n          `DataTypeTemplates > DAType[id=\"${type}\"]`\n        );\n      } else {\n        typeElement = null;\n      }\n    }\n  });\n  return templateStructure;\n}\n"]}