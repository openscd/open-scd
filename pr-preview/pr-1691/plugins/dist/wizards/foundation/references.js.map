{"version":3,"file":"references.js","sourceRoot":"","sources":["../../../src/wizards/foundation/references.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  getNameAttribute,\n  isPublic,\n} from '@openscd/open-scd/src/foundation.js';\nimport {\n  Delete,\n  Replace\n} from '@openscd/core/foundation/deprecated/editor';\nconst referenceInfoTags = ['IED', 'Substation', 'VoltageLevel', 'Bay'] as const;\ntype ReferencesInfoTag = (typeof referenceInfoTags)[number];\n\ntype FilterFunction = (\n  element: Element,\n  attributeName: string | null,\n  oldName: string | null\n) => string;\n\n/*\n * For every supported tag a list of information about which elements to search for and which attribute value\n * to replace with the new value typed in the screen by the user. This is used to update references to a name\n * of an element by other elements.\n * If the attributeName is null the text content of the found element will be replaced.\n */\nconst referenceInfos: Record<\n  ReferencesInfoTag,\n  {\n    attributeName: string | null;\n    filter: FilterFunction;\n  }[]\n> = {\n  IED: [\n    {\n      attributeName: 'iedName',\n      filter: simpleAttributeFilter(`Association`),\n    },\n    {\n      attributeName: 'iedName',\n      filter: simpleAttributeFilter(`ClientLN`),\n    },\n    {\n      attributeName: 'iedName',\n      filter: simpleAttributeFilter(`ConnectedAP`),\n    },\n    {\n      attributeName: 'iedName',\n      filter: simpleAttributeFilter(`ExtRef`),\n    },\n    {\n      attributeName: 'iedName',\n      filter: simpleAttributeFilter(`KDC`),\n    },\n    {\n      attributeName: 'iedName',\n      filter: simpleAttributeFilter(`LNode`),\n    },\n    {\n      attributeName: null,\n      filter: simpleTextContentFilter(`GSEControl > IEDName`),\n    },\n    {\n      attributeName: null,\n      filter: simpleTextContentFilter(`SampledValueControl > IEDName`),\n    },\n    {\n      attributeName: null,\n      filter: simpleTextContentFilter(`LN > DOI > DAI > Val`),\n    },\n  ],\n  Substation: [\n    {\n      attributeName: 'substationName',\n      filter: simpleAttributeFilter(`Terminal`),\n    },\n  ],\n  VoltageLevel: [\n    {\n      attributeName: 'voltageLevelName',\n      filter: attributeFilterWithParentNameAttribute(`Terminal`, {\n        Substation: 'substationName',\n      }),\n    },\n  ],\n  Bay: [\n    {\n      attributeName: 'bayName',\n      filter: attributeFilterWithParentNameAttribute(`Terminal`, {\n        Substation: 'substationName',\n        VoltageLevel: 'voltageLevelName',\n      }),\n    },\n  ],\n};\n\n/**\n * Simple function to create a filter to find Elements where the value of an attribute equals the old name.\n *\n * @param tagName - The tagName of the elements to search for.\n */\nfunction simpleAttributeFilter(tagName: string) {\n  return function filter(\n    element: Element,\n    attributeName: string | null,\n    oldName: string | null\n  ): string {\n    return `${tagName}[${attributeName}=\"${oldName}\"]`;\n  };\n}\n\n/**\n * Simple function to search for Elements for which the text content may contain the old name.\n * Because the text content of an element can't be search for in a CSS Selector this is done afterwards.\n *\n * @param elementQuery - The CSS Query to search for the Elements.\n */\nfunction simpleTextContentFilter(elementQuery: string) {\n  return function filter(): string {\n    return `${elementQuery}`;\n  };\n}\n\n/**\n * More complex function to search for elements for which the value of an attribute needs to be updated.\n * To find the correct element the name of a parent element also needs to be included in the search.\n *\n * For instance when the name of a Bay is updated only the terminals need to be updated where of course\n * the old name of the bay is the value of the attribute 'bayName', but also the voltage level and substation\n * name need to be included, because the name of the bay is only unique within the voltage level.\n * The query will then become\n * `Terminal[substationName=\"<substationName>\"][voltageLevelName=\"<voltageLevelName>\"][bayName=\"<oldName>\"]`\n *\n * @param tagName    - The tagName of the elements to search for.\n * @param parentInfo - The records of parent to search for, the key is the tagName of the parent, the value\n *                     is the name of the attribuet to use in the query.\n */\nfunction attributeFilterWithParentNameAttribute(\n  tagName: string,\n  parentInfo: Record<string, string>\n) {\n  return function filter(\n    element: Element,\n    attributeName: string | null,\n    oldName: string | null\n  ): string {\n    return `${tagName}${\n      Object.entries(parentInfo)\n        .map(([parentTag, parentAttribute]) => {\n          const parentElement = element.closest(parentTag);\n          if (parentElement && parentElement.hasAttribute('name')) {\n            const name = parentElement.getAttribute('name');\n            return `[${parentAttribute}=\"${name}\"]`;\n          }\n          return null;\n        })\n        .join('') // Join the strings to 1 string without a separator.\n    }[${attributeName}=\"${oldName}\"]`;\n  };\n}\n\n/**\n * Clone an element with the attribute name passed and process the new value. If the new value\n * is null the attribute will be removed otherwise the value of the attribute is updated.\n *\n * @param element       - The element to clone.\n * @param attributeName - The name of the attribute to copy.\n * @param value         - The value to set on the cloned element or if null remove the attribute.\n * @returns Returns the cloned element.\n */\nfunction cloneElement(\n  element: Element,\n  attributeName: string,\n  value: string\n): Element {\n  const newElement = <Element>element.cloneNode(false);\n  newElement.setAttribute(attributeName, value);\n  return newElement;\n}\n\n/**\n * Clone an element and set the value as text content on the cloned element.\n *\n * @param element - The element to clone.\n * @param value   - The value to set.\n * @returns Returns the cloned element.\n */\nfunction cloneElementAndTextContent(\n  element: Element,\n  value: string | null\n): Element {\n  const newElement = <Element>element.cloneNode(false);\n  newElement.textContent = value;\n  return newElement;\n}\n\n/**\n * Function to create Replace actions to update reference which point to the name of the element being updated.\n * For instance the IED Name is used in other SCL Elements as attribute 'iedName' to reference the IED.\n * These attribute values need to be updated if the name of the IED changes.\n *\n * An empty array will be returned if the old and new value are the same or no references need to be updated.\n *\n * @param element - The element for which the name is updated.\n * @param oldName - The old name of the element.\n * @param newName - The new name of the element.\n * @returns Returns a list of Replace Actions that can be added to a Complex Action or returned directly for execution.\n */\nexport function updateReferences(\n  element: Element,\n  oldName: string | null,\n  newName: string\n): Replace[] {\n  if (oldName === null || oldName === newName) {\n    return [];\n  }\n\n  const referenceInfo = referenceInfos[<ReferencesInfoTag>element.tagName];\n  if (referenceInfo === undefined) {\n    return [];\n  }\n\n  const actions: Replace[] = [];\n  referenceInfo.forEach(info => {\n    // Depending on if an attribute value needs to be updated or the text content of an element\n    // different scenarios need to be executed.\n    const filter = info.filter(element, info.attributeName, oldName);\n    if (info.attributeName) {\n      Array.from(element.ownerDocument.querySelectorAll(`${filter}`))\n        .filter(isPublic)\n        .forEach(element => {\n          const newElement = cloneElement(\n            element,\n            info.attributeName!,\n            newName\n          );\n          actions.push({ old: { element }, new: { element: newElement } });\n        });\n    } else {\n      // If the text content needs to be updated, filter on the text content can't be done in a CSS Selector.\n      // So we query all elements the may need to be updated and filter them afterwards.\n      Array.from(element.ownerDocument.querySelectorAll(`${filter}`))\n        .filter(element => element.textContent === oldName)\n        .filter(isPublic)\n        .forEach(element => {\n          const newElement = cloneElementAndTextContent(element, newName);\n          actions.push({ old: { element }, new: { element: newElement } });\n        });\n    }\n  });\n\n  if (element.tagName === 'IED')\n    actions.push(...updateVals(element, oldName, newName));\n  return actions;\n}\n\n/**\n * Adds Replace actions to update supervision references.\n * Only a maximum of one Val element per IED with ExtRef elements that contain src attributes will be altered.\n * The Val element that needs to be altered will be found by checking if the controlBlockReference complies with this element.\n * The controlBlockReference needs to contain the IED that gets renamed.\n *\n * @param element - The element for which the name is updated.\n * @param oldName - The old name of the element.\n * @param newName - The new name of the element.\n */\nfunction updateVals(element: Element, oldName: string | null, newName: string) {\n  const actions: Replace[] = [];\n  const ieds = element.ownerDocument.querySelectorAll('IED');\n  ieds.forEach(ied => {\n    // All Val elements inside LGOS and LSVS lnClasses that starts with the IED name that needs to be changed will be gathered.\n    // Because of a very rare case where multiple IED start with the same name, all will be gathered.\n    // If none are found continue to the next IED.\n    const valValues: Element[] = Array.from(\n      ied.querySelectorAll(\n        `:scope > AccessPoint > Server > LDevice > LN[lnClass=\"LGOS\"] > DOI > DAI > Val, :scope > AccessPoint > Server > LDevice > LN[lnClass=\"LSVS\"] > DOI > DAI > Val`\n      )\n    );\n\n    if (valValues.length === 0) return;\n\n    // If atleast one extRef element contains the to-be-changed IED name and has a srcCBName, one will be gathered.\n    // From that extRef element a controlblockreferences will be created and compared to the Val elements.\n    // If a match is found, the name of that Val element will be changed accordingly and the loop will be broken, as only 1 Val element need to be changed.\n\n    const ref = ied.querySelector(\n      `:scope > AccessPoint > Server > LDevice > LN0 > Inputs > ExtRef[iedName=\"${oldName}\"][srcCBName]`\n    );\n\n    const suffixCBReference =\n      ref?.getAttribute('srcLDInst') +\n      '/' +\n      ref?.getAttribute('srcLNClass') +\n      '.' +\n      ref?.getAttribute('srcCBName');\n\n    for (let value of valValues) {\n      if (oldName + suffixCBReference === value.textContent!.trim()) {\n        const newElement = cloneElementAndTextContent(\n          value,\n          newName + suffixCBReference\n        );\n        actions.push({\n          old: { element: value },\n          new: { element: newElement },\n        });\n        break;\n      }\n    }\n  });\n\n  return actions;\n}\n\n/**\n * Function to create Delete actions to remove reference which point to the name of the element being removed.\n * For instance the IED Name is used in other SCL Elements as attribute 'iedName' to reference the IED.\n * These elements need to be removed if the IED is removed.\n *\n * @param element - The element that will be removed and it's name is used to search for references.\n * @returns Returns a list of Delete Actions that can be added to a Complex Action or returned directly for execution.\n */\nexport function deleteReferences(element: Element): Delete[] {\n  const name = getNameAttribute(element) ?? null;\n  if (name === null) {\n    return [];\n  }\n\n  const referenceInfo = referenceInfos[<ReferencesInfoTag>element.tagName];\n  if (referenceInfo === undefined) {\n    return [];\n  }\n\n  const actions: Delete[] = [];\n  referenceInfo.forEach(info => {\n    // Depending on if an attribute value is used for filtering or the text content of an element\n    // different scenarios need to be executed.\n    const filter = info.filter(element, info.attributeName, name);\n    if (info.attributeName) {\n      Array.from(element.ownerDocument.querySelectorAll(`${filter}`))\n        .filter(isPublic)\n        .forEach(element => {\n          actions.push({ old: { parent: element.parentElement!, element } });\n        });\n    } else {\n      // If the text content needs to be used for filtering, filter on the text content can't be done in a CSS Selector.\n      // So we query all elements the may need to be deleted and filter them afterwards.\n      Array.from(element.ownerDocument.querySelectorAll(`${filter}`))\n        .filter(element => element.textContent === name)\n        .filter(isPublic)\n        .forEach(element => {\n          // We not only need to remove the element containing the text content, but the parent of this element.\n          if (element.parentElement) {\n            actions.push({\n              old: {\n                parent: element.parentElement.parentElement!,\n                element: element.parentElement,\n              },\n            });\n          }\n        });\n    }\n  });\n  return actions;\n}\n"]}